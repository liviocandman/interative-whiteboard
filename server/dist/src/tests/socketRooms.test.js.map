{"version":3,"sources":["../../../src/tests/socketRooms.test.ts"],"sourcesContent":["import { describe, it, expect, beforeAll, afterAll } from \"vitest\";\r\nimport { io as Client, Socket } from \"socket.io-client\";\r\nimport { createServer } from \"http\";\r\nimport express from \"express\";\r\nimport { Server } from \"socket.io\";\r\nimport { initRedis, pubClient, subClient } from \"../config/redis\";\r\nimport { setupSocket } from \"../socket/setupSocket\";\r\n\r\nconst PORT = 4000;\r\nlet io: Server;\r\nlet httpServer: ReturnType<typeof createServer>;\r\n\r\ndescribe(\"Test multiple users in different rooms\", () => {\r\n  let clientA: Socket;\r\n  let clientB: Socket;\r\n\r\n  beforeAll(async () => {\r\n    await initRedis();\r\n\r\n    const app = express();\r\n    httpServer = createServer(app);\r\n    io = new Server(httpServer, { cors: { origin: \"*\" } });\r\n\r\n    await setupSocket(io);\r\n\r\n    await new Promise<void>((resolve) => {\r\n      httpServer.listen(PORT, () => {\r\n        console.log(`Test server running on port ${PORT}`);\r\n        resolve();\r\n      });\r\n    });\r\n\r\n    clientA = Client(`http://localhost:${PORT}`);\r\n    clientB = Client(`http://localhost:${PORT}`);\r\n  });\r\n\r\n  afterAll(async () => {\r\n    clientA.disconnect();\r\n    clientB.disconnect();\r\n    io.close();\r\n    httpServer.close();\r\n    await pubClient.quit();\r\n    await subClient.quit();\r\n  });\r\n\r\n  it(\"User A and B join different rooms and do not receive cross events\", async () => {\r\n    const roomA = \"room-1\";\r\n    const roomB = \"room-2\";\r\n\r\n    let receivedA = false;\r\n    let receivedB = false;\r\n\r\n    clientA.emit(\"joinRoom\", roomA);\r\n    clientB.emit(\"joinRoom\", roomB);\r\n\r\n    clientA.on(\"drawing\", () => {\r\n      receivedA = true;\r\n    });\r\n\r\n    clientB.on(\"drawing\", () => {\r\n      receivedB = true;\r\n    });\r\n\r\n    // User A sends a drawing event\r\n    clientA.emit(\"drawing\", { x: 10, y: 20 });\r\n\r\n    // Aguarde um pouco para os eventos propagarem\r\n    await new Promise((res) => setTimeout(res, 400));\r\n\r\n    expect(receivedA).toBe(true);  // A should receive its own event\r\n    expect(receivedB).toBe(false); // B should not receive A's event\r\n  });\r\n});\r\n"],"names":["PORT","io","httpServer","describe","clientA","clientB","beforeAll","initRedis","app","express","createServer","Server","cors","origin","setupSocket","Promise","resolve","listen","console","log","Client","afterAll","disconnect","close","pubClient","quit","subClient","it","roomA","roomB","receivedA","receivedB","emit","on","x","y","res","setTimeout","expect","toBe"],"mappings":";;;;wBAA0D;gCACrB;sBACR;gEACT;0BACG;uBACyB;6BACpB;;;;;;AAE5B,MAAMA,OAAO;AACb,IAAIC;AACJ,IAAIC;AAEJC,IAAAA,gBAAQ,EAAC,0CAA0C;IACjD,IAAIC;IACJ,IAAIC;IAEJC,IAAAA,iBAAS,EAAC;QACR,MAAMC,IAAAA,gBAAS;QAEf,MAAMC,MAAMC,IAAAA,gBAAO;QACnBP,aAAaQ,IAAAA,kBAAY,EAACF;QAC1BP,KAAK,IAAIU,gBAAM,CAACT,YAAY;YAAEU,MAAM;gBAAEC,QAAQ;YAAI;QAAE;QAEpD,MAAMC,IAAAA,wBAAW,EAACb;QAElB,MAAM,IAAIc,QAAc,CAACC;YACvBd,WAAWe,MAAM,CAACjB,MAAM;gBACtBkB,QAAQC,GAAG,CAAC,CAAC,4BAA4B,EAAEnB,MAAM;gBACjDgB;YACF;QACF;QAEAZ,UAAUgB,IAAAA,kBAAM,EAAC,CAAC,iBAAiB,EAAEpB,MAAM;QAC3CK,UAAUe,IAAAA,kBAAM,EAAC,CAAC,iBAAiB,EAAEpB,MAAM;IAC7C;IAEAqB,IAAAA,gBAAQ,EAAC;QACPjB,QAAQkB,UAAU;QAClBjB,QAAQiB,UAAU;QAClBrB,GAAGsB,KAAK;QACRrB,WAAWqB,KAAK;QAChB,MAAMC,gBAAS,CAACC,IAAI;QACpB,MAAMC,gBAAS,CAACD,IAAI;IACtB;IAEAE,IAAAA,UAAE,EAAC,qEAAqE;QACtE,MAAMC,QAAQ;QACd,MAAMC,QAAQ;QAEd,IAAIC,YAAY;QAChB,IAAIC,YAAY;QAEhB3B,QAAQ4B,IAAI,CAAC,YAAYJ;QACzBvB,QAAQ2B,IAAI,CAAC,YAAYH;QAEzBzB,QAAQ6B,EAAE,CAAC,WAAW;YACpBH,YAAY;QACd;QAEAzB,QAAQ4B,EAAE,CAAC,WAAW;YACpBF,YAAY;QACd;QAEA,+BAA+B;QAC/B3B,QAAQ4B,IAAI,CAAC,WAAW;YAAEE,GAAG;YAAIC,GAAG;QAAG;QAEvC,8CAA8C;QAC9C,MAAM,IAAIpB,QAAQ,CAACqB,MAAQC,WAAWD,KAAK;QAE3CE,IAAAA,cAAM,EAACR,WAAWS,IAAI,CAAC,OAAQ,iCAAiC;QAChED,IAAAA,cAAM,EAACP,WAAWQ,IAAI,CAAC,QAAQ,iCAAiC;IAClE;AACF"}