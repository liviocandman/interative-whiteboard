{"version":3,"sources":["../../../src/tests/socketSameRoom.test.ts"],"sourcesContent":["import { describe, it, expect, beforeAll, afterAll } from \"vitest\";\r\nimport { io as Client, Socket } from \"socket.io-client\";\r\nimport { createServer } from \"http\";\r\nimport express from \"express\";\r\nimport { Server } from \"socket.io\";\r\nimport { initRedis, pubClient, subClient } from \"../config/redis\";\r\nimport { setupSocket } from \"../socket/setupSocket\";\r\n\r\nconst PORT = 5051;\r\nlet io: Server;\r\nlet httpServer: ReturnType<typeof createServer>;\r\n\r\ndescribe(\"Real-time synchronization in the same room\", () => {\r\n  let clientA: Socket;\r\n  let clientB: Socket;\r\n\r\n  beforeAll(async () => {\r\n    await initRedis();\r\n\r\n    const app = express();\r\n    httpServer = createServer(app);\r\n    io = new Server(httpServer, { cors: { origin: \"*\" } });\r\n\r\n    await setupSocket(io);\r\n\r\n    await new Promise<void>((resolve) => {\r\n      httpServer.listen(PORT, () => {\r\n        console.log(`Test server running on port ${PORT}`);\r\n        resolve();\r\n      });\r\n    });\r\n\r\n    clientA = Client(`http://localhost:${PORT}`);\r\n    clientB = Client(`http://localhost:${PORT}`);\r\n  });\r\n\r\n  afterAll(async () => {\r\n    clientA.disconnect();\r\n    clientB.disconnect();\r\n    io.close();\r\n    httpServer.close();\r\n    await pubClient.quit();\r\n    await subClient.quit();\r\n  });\r\n\r\n  it(\"User A sends drawing and User B receives it in the same room\", async () => {\r\n    const roomId = \"shared-room\";\r\n\r\n    let receivedB = false;\r\n\r\n    // Both join the same room\r\n    clientA.emit(\"joinRoom\", roomId);\r\n    clientB.emit(\"joinRoom\", roomId);\r\n\r\n    // B listens for drawing event\r\n    clientB.on(\"drawing\", (stroke) => {\r\n      if (stroke?.x === 10 && stroke?.y === 20) {\r\n        receivedB = true;\r\n      }\r\n    });\r\n\r\n    // A sends a drawing\r\n    clientA.emit(\"drawing\", { x: 10, y: 20 });\r\n\r\n    // Wait for propagation\r\n    await new Promise((res) => setTimeout(res, 500));\r\n\r\n    expect(receivedB).toBe(true);\r\n  });\r\n});\r\n"],"names":["PORT","io","httpServer","describe","clientA","clientB","beforeAll","initRedis","app","express","createServer","Server","cors","origin","setupSocket","Promise","resolve","listen","console","log","Client","afterAll","disconnect","close","pubClient","quit","subClient","it","roomId","receivedB","emit","on","stroke","x","y","res","setTimeout","expect","toBe"],"mappings":";;;;wBAA0D;gCACrB;sBACR;gEACT;0BACG;uBACyB;6BACpB;;;;;;AAE5B,MAAMA,OAAO;AACb,IAAIC;AACJ,IAAIC;AAEJC,IAAAA,gBAAQ,EAAC,8CAA8C;IACrD,IAAIC;IACJ,IAAIC;IAEJC,IAAAA,iBAAS,EAAC;QACR,MAAMC,IAAAA,gBAAS;QAEf,MAAMC,MAAMC,IAAAA,gBAAO;QACnBP,aAAaQ,IAAAA,kBAAY,EAACF;QAC1BP,KAAK,IAAIU,gBAAM,CAACT,YAAY;YAAEU,MAAM;gBAAEC,QAAQ;YAAI;QAAE;QAEpD,MAAMC,IAAAA,wBAAW,EAACb;QAElB,MAAM,IAAIc,QAAc,CAACC;YACvBd,WAAWe,MAAM,CAACjB,MAAM;gBACtBkB,QAAQC,GAAG,CAAC,CAAC,4BAA4B,EAAEnB,MAAM;gBACjDgB;YACF;QACF;QAEAZ,UAAUgB,IAAAA,kBAAM,EAAC,CAAC,iBAAiB,EAAEpB,MAAM;QAC3CK,UAAUe,IAAAA,kBAAM,EAAC,CAAC,iBAAiB,EAAEpB,MAAM;IAC7C;IAEAqB,IAAAA,gBAAQ,EAAC;QACPjB,QAAQkB,UAAU;QAClBjB,QAAQiB,UAAU;QAClBrB,GAAGsB,KAAK;QACRrB,WAAWqB,KAAK;QAChB,MAAMC,gBAAS,CAACC,IAAI;QACpB,MAAMC,gBAAS,CAACD,IAAI;IACtB;IAEAE,IAAAA,UAAE,EAAC,gEAAgE;QACjE,MAAMC,SAAS;QAEf,IAAIC,YAAY;QAEhB,0BAA0B;QAC1BzB,QAAQ0B,IAAI,CAAC,YAAYF;QACzBvB,QAAQyB,IAAI,CAAC,YAAYF;QAEzB,8BAA8B;QAC9BvB,QAAQ0B,EAAE,CAAC,WAAW,CAACC;YACrB,IAAIA,QAAQC,MAAM,MAAMD,QAAQE,MAAM,IAAI;gBACxCL,YAAY;YACd;QACF;QAEA,oBAAoB;QACpBzB,QAAQ0B,IAAI,CAAC,WAAW;YAAEG,GAAG;YAAIC,GAAG;QAAG;QAEvC,uBAAuB;QACvB,MAAM,IAAInB,QAAQ,CAACoB,MAAQC,WAAWD,KAAK;QAE3CE,IAAAA,cAAM,EAACR,WAAWS,IAAI,CAAC;IACzB;AACF"}